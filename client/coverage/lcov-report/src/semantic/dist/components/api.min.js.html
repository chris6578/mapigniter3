<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for src/semantic/dist/components/api.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../../../index.html">All files</a> / <a href="index.html">src/semantic/dist/components</a> api.min.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/161</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/352</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/81</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/1</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">!function(e,t<span class="cstat-no" title="statement not covered" >,<span class="fstat-no" title="function not covered" >r,</span>n){"use strict";t=void 0!==t&amp;&amp;t.Ma<span class="cstat-no" title="statement not covered" >th==Math?t:"undefined"!=typeof self&amp;&amp;self.Math==Math?self:Function("return this")();e.api=e.fn.api=function(r){var o,s=e.isF<span class="cstat-no" title="statement not covered" >u</span>nction(this)?e(t):<span class="fstat-no" title="function not covered" >e(</span>this),i=s.selector||""<span class="cstat-no" title="statement not covered" >,a=(new Date).getTime(),u=[],c=argum</span>ents<span class="cstat-no" title="statement not covered" >[0],d="string"==t</span>ypeo<span class="cstat-no" title="statement not covered" >f c,l=[].slice.call(a</span>rgum<span class="cstat-no" title="statement not covered" >ent</span>s,1)<span class="cstat-no" title="statement not covered" >;return s.eac</span>h(fu<span class="cstat-no" title="statement not covered" >nction(){var s,g,f,p,</span>m,b,<span class="cstat-no" title="statement not covered" >v=e.isPlainObject(r)?e.exten<span class="cstat-no" title="statement not covered" ></span>d(!0,{},e.fn.a<span class="fstat-no" title="function not covered" >pi</span>.settings,r):e.extend({},e.fn.a<span class="cstat-no" title="statement not covered" >pi.settings),h=v.namespace,y=v.metadata,q=v.selector,R=v.error,x=v.className,S="."+h,A="module</span>-"+h<span class="cstat-no" title="statement not covered" >,k=e(this),T</span>=k.c<span class="cstat-no" title="statement not covered" >losest(q.fo</span>rm),<span class="cstat-no" title="statement not covered" >P=v.stateCo</span>ntex<span class="cstat-no" title="statement not covered" >t?e(v.st</span>ateC<span class="cstat-no" title="statement not covered" >ontext):k,j=</span>this<span class="cstat-no" title="statement not covered" >,O=P[0],</span>w=k.<span class="cstat-no" title="statement not covered" >data(A);b={ini</span>tial<span class="cstat-no" title="statement not covered" >ize:func</span>tion<span class="cstat-no" title="statement not covered" >(){d||b.bind.event</span>s(),<span class="cstat-no" title="statement not covered" >b.instantiate()},instantiate:function()</span>{b.v<span class="cstat-no" title="statement not covered" >erbos</span>e("S<span class="cstat-no" title="statement not covered" >torin</span>g in<span class="cstat-no" title="statement not covered" >stance of <span class="cstat-no" title="statement not covered" ></span>module",b),w=b,k.d<span class="fstat-no" title="function not covered" >at</span>a(A,w)},des<span class="cstat-no" title="statement not covered" >troy:function(){b.verbose("Destroying p</span>revious module <span class="fstat-no" title="function not covered" >fo</span>r",j),k.rem<span class="cstat-no" title="statement not covered" >oveData(A).off(S)},bind:{events:function(){var e=b.get.event();e?</span>(b.verbose(<span class="fstat-no" title="function not covered" >"A</span>ttaching AP<span class="cstat-no" title="statement not covered" >I events to element",e),k.on(e+S,b.event.trigger)):"now"==v.on&amp;&amp;(b.debug</span>("Querying API end<span class="fstat-no" title="function not covered" >po</span>int immediately"),b<span class="cstat-no" title="statement not covered" >.query())}},de<span class="cstat-no" title="statement not covered" ></span>code:{json:function(e){if(e!==n&amp;&amp;"string"==typeof e)try{e=JSON.parse(e)}catch(e){}return e}},read:{cachedResponse:function(e){var r;if(t.Storage!==n)return r=sess</span>ionStorage.getItem(e<span class="fstat-no" title="function not covered" >),</span>b.debug("Usi<span class="cstat-no" title="statement not covered" >ng cached response",e,r),r=b.decode.j<span class="cstat-no" title="statement not covered" >son(r<span class="cstat-no" title="statement not covered" >);b.error(R.noStora</span>ge)}},write:{<span class="cstat-no" title="statement not covered" >c</span></span>achedResp</span>onse:function(r,o){o&amp;&amp;""===o<span class="fstat-no" title="function not covered" >?b</span>.debug("Response e<span class="cstat-no" title="statement not covered" >mpty, not caching",o)<span class="cstat-no" title="statement not covered" >:t.Storage!==n?(e.isPlainObject(o)&amp;&amp;(o=JSON.stringify(o)),sessionStorage.setItem(r,o),b.verbose("St<span class="cstat-no" title="statement not covered" >o</span></span>ring cached response </span>for url",r,o)):b.error(R.noSt<span class="fstat-no" title="function not covered" >or</span>age)}},query:fu<span class="cstat-no" title="statement not covered" >nction(){if(b.is.disabled())b.debug("Element is disabled API request aborted");else{if(b.is.loading()){if(!v.interruptRequests)return void b.debug("Cancelling request, previous request is still pending");b.debug("Interrupting previo</span>us request"<span class="fstat-no" title="function not covered" >),</span>b.abort()}i<span class="cstat-no" title="statement not covered" >f(v.defaultData&amp;&amp;e.ex<span class="cstat-no" title="statement not covered" >tend(!0,v.urlData,b.get.defaultData()),v.serializeFo</span>rm&amp;&amp;(<span class="cstat-no" title="statement not covered" >v.data=b.add.formData<span class="cstat-no" title="statement not covered" >(v.data)),!1===(g=b.get.se<span class="cstat-no" title="statement not covered" >ttings()))return b.cancelled=!0,void b.error(R.beforeSend);if(b.cancelled=!1,<span class="cstat-no" title="statement not covered" >(</span></span>f=b.get.templatedURL())||b.is.mocked()){if((f=b.add.<span class="cstat-no" title="statement not covered" ></span>u</span>rlData(f))||b.is.mocked()){if(g.url=v.base+f,s=e.extend(!0,{},v,{type:v.method||v.type,data:p,url:v.base+f,beforeSend:v.beforeXHR,success:function(){},<span class="cstat-no" title="statement not covered" >failure:function(){},complete:function(){}}),b.debug<span class="cstat-no" title="statement not covered" >(</span></span>"Querying URL",s.url),b.verbose("Using AJAX settings",s),"local"===<span class="cstat-no" title="statement not covered" >v.cache&amp;&amp;b.read.cachedResponse(f))return b.deb<span class="cstat-no" title="statement not covered" >ug("Response returned from local cache"),b.request=b.create.request(),void b.request.resolveWith(O,[b.read.cachedResponse(f)]);v.throttl<span class="fstat-no" title="function not covered" >e?</span>v.throttleFirstRequest|<span class="fstat-no" title="function not covered" >|b</span>.timer?(b.debug("Throttl<span class="fstat-no" title="function not covered" >in</span>g request",v.throttle),clearTimeout(b.timer),b.timer=setTimeout(function(){b.timer&amp;&amp;delete b.timer,b.debug("Sending throttled request",<span class="cstat-no" title="statement not covered" >p,s.method),b.send.request()},v.throttle)):(b.debug("Sending request",p,s.method),b.send.request(),b.timer=setTimeout(function(){},v.throttle)):<span class="cstat-no" title="statement not covered" >(</span></span>b.debug("Sending request",p,s.method),b.send.request())}}else b.error(R.missingURL)}},should:{removeError:function(){return!0===v.hideEr<span class="fstat-no" title="function not covered" >ro</span>r||"auto"==<span class="cstat-no" title="statement not covered" >=v.hideError&amp;&amp;!b.is.form()}},is:{disabled:function(){return k.filter(q.disabled).length&gt;0},expec</span>tingJSON:function(){return"json"===v.dataType||"jsonp"===v.dataType},form:function(){return k.is("<span class="fstat-no" title="function not covered" >fo</span>rm")||P.is("form")},mocked:function(){return v.mockResponse||v.mockResponseAsync||v.respon</span>s</span>e||v.r<span class="cstat-no" title="statement not covered" >esponseAsync},input:fun</span></span>c</span>tion(){return k.is("input<span class="fstat-no" title="function not covered" >")</span>},loading:f<span class="cstat-no" title="statement not covered" >unction(){return!!b.request&amp;&amp;"pending"==b.request.state()},abortedReq</span>uest:function(e){ret<span class="fstat-no" title="function not covered" >ur</span>n e&amp;&amp;e.read<span class="cstat-no" title="statement not covered" >yState!==n&amp;&amp;0===e.readyState?(b.verbose(</span>"XHR request dete<span class="fstat-no" title="function not covered" >rm</span>ined to be <span class="cstat-no" title="statement not covered" >aborted"),!0):(b.verbose("XHR request was not aborted"),</span>!1)},val<span class="fstat-no" title="function not covered" >id</span>Response:fu<span class="cstat-no" title="statement not covered" >nction(t){return b.is.expectingJSON()</span>&amp;&amp;e.isFunc<span class="fstat-no" title="function not covered" >ti</span>on(v.succes<span class="cstat-no" title="statement not covered" >sTest)?(b.debug("Checking JSON returned success",v.successTest,t),v.successTest</span>(t)?(b.de<span class="fstat-no" title="function not covered" >bu</span>g("Response<span class="cstat-no" title="statement not covered" > passed success test",</span>t),!0):(b.d<span class="fstat-no" title="function not covered" >eb</span>ug("Respons<span class="cstat-no" title="statement not covered" >e failed success test",t),!1)):(b.verbose("Response is</span> not JSON, skippin<span class="fstat-no" title="function not covered" >g </span>validation",<span class="cstat-no" title="statement not covered" >v.successTest,t),!0)}},was:{cancelled:function(){return b.cancelled||!1},succesful:function(){return b.request&amp;&amp;"resolved"==b.request.state()},failure:function()</span>{return b.request<span class="fstat-no" title="function not covered" >&amp;&amp;</span>"rejected"==<span class="cstat-no" title="statement not covered" >b.request.state()},complete:function(){return b.request&amp;&amp;("resolved"==b.request.state()||"rejected"==b.request.state())}},add:{urlData:function(t,r){var o,s;return t&amp;&amp;(o=t.match(v.regExp.required),s=t.match(v.regExp.optional),r=r||v.urlData,o&amp;&amp;(b.debug("Looking for required URL variables",o),e.each(o,function(o,s){var i=-1!</span>==s.indexOf("$")?s.sub<span class="fstat-no" title="function not covered" >st</span>r(2,s.lengt<span class="cstat-no" title="statement not covered" >h-3):s.substr(1,s.length-2</span>),a=e.isPlain<span class="fstat-no" title="function not covered" >Ob</span>ject(r)&amp;&amp;r[<span class="cstat-no" title="statement not covered" >i]!==n?r[i]:k.data(i)!==n?k.data(i):P.data(i)!==n?P.d</span>ata(i):r[i]<span class="fstat-no" title="function not covered" >;i</span>f(a===n)ret<span class="cstat-no" title="statement not covered" >urn b.error(R.requiredParameter,i,t),t=!1,!1;b.verbos</span>e("Found req<span class="fstat-no" title="function not covered" >ui</span>red variabl<span class="cstat-no" title="statement not covered" >e",i,a),a=v.encodeParameters?b.get.urlEncodedValue(a):a,t=t.replace(s,a)})),s&amp;&amp;(b.debug("L</span>ooking for optional <span class="fstat-no" title="function not covered" >UR</span>L variables",o),e.each(s<span class="cstat-no" title="statement not covered" >,function(o,s){var i=-1!==s.indexOf("$")?s.substr(3,s.length-4):s.substr(2,s.length-3),a=e.isPlainObject(r)&amp;&amp;r[i]!==n?r[i]:k.data(i)!==n?k.data(i):P.data(i)!==n?P.<span class="fstat-no" title="function not covered" >da</span>ta(i):r[i];a!==n?(b.ver<span class="cstat-no" title="statement not covered" >bose("Optional variable Found",i,a),t=t.replace(s,a)):(b.verbose("Optional var</span>iabl<span class="cstat-no" title="statement not covered" >e not found",i),t=-1!==t.indexOf("/"+s)?t.replace("/"+s,""):t.replace(s,""))}))),t},formData:function(t){va<span class="cstat-no" title="statement not covered" ></span>r r=e.fn.seri<span class="cstat-no" title="statement not covered" >alizeObject!==n,o=r?T.serializeObject():T.serialize();<span class="cstat-no" title="statement not covered" >r</span></span>eturn t=t||v.data,e.isPlainObject(t)?r?(b.debug("Extending existing data with form data",t,o),t=e.extend(!0,{},t,o)):(b</span>.error(R.missingSerialize),b.debug("Cant extend data. Replacing data w<span class="fstat-no" title="function not covered" >it</span>h form data",t,o),t=o):<span class="cstat-no" title="statement not covered" >(b.debug("Adding form data",o),t=o),t}},send:{request:function(){b.set.loading</span>(),b<span class="cstat-no" title="statement not covered" >.request=b.create.request(),b.is.mocked()?b.mockedXHR=b.create.mockedXHR():b.xhr=b.create.xhr(),v.onRequest<span class="cstat-no" title="statement not covered" ></span>.call(O,b.request,b.xhr)}},event:{trigger:function(e){b.query(),"submit"!=e.type&amp;&amp;"click"!=e.type||e.preventDefault()},xhr:{always:function(){},done:function(t,r,n){var o=this,s=(new Date).getTime()-m</span>,i=v.loa</span>dingDuration<span class="fstat-no" title="function not covered" >-s</span>,a=!!e.isFunction(v.<span class="cstat-no" title="statement not covered" >onResponse)&amp;&amp;(b.is.expectin</span>gJSO<span class="cstat-no" title="statement not covered" >N()?v.onResponse.call(o,e.extend(!0,{},t<span class="cstat-no" title="statement not covered" ></span>)):v.onResponse.call(o,t));i=i&gt;0?i:0,a&amp;&amp;(b.debug("Modified API response in onResponse callback",v.onResponse,a,t),t=a),i&gt;0&amp;&amp;b.debug("Response completed early delaying state change by",i),setTimeout(function(){b.is.validResponse(t)?b.request.resolveWith(o,[t,n]):b.request.rejectWith(o,[</span>n,"invalid"])},i)},fa<span class="fstat-no" title="function not covered" >il</span>:function(e<span class="cstat-no" title="statement not covered" >,t,r){var n=this,o=(new Date).getTime()-m,s=v.loadingDuration-o;(s=s&gt;0?s:0)&gt;0&amp;&amp;b.debug("Response completed early delaying state change by",s),setTimeout(function(){b</span>.is.abortedRequest(e)?<span class="fstat-no" title="function not covered" >b.</span>request.reje<span class="cstat-no" title="statement not covered" >ctWith(n,[e,"aborted",r]):b.request.rejectWith(n,[e,"error",t,r])},s)}},re</span>quest:{done:funct<span class="fstat-no" title="function not covered" >io</span>n(e,t){b.debug("Succ<span class="fstat-no" title="function not covered" >es</span>sful API Response",e),"loc<span class="cstat-no" title="statement not covered" >al"==</span>=v.c<span class="cstat-no" title="statement not covered" >ache&amp;&amp;f&amp;&amp;(b.write.cachedR</span>espo<span class="cstat-no" title="statement not covered" >nse(f,e),b.debug("Savi</span>ng s<span class="cstat-no" title="statement not covered" >erver response locally",b.cache)),v.onSuccess.call(O,e,k,t)},complete:function(e,t){var r,n;b.was.succesful()?(n=e,r=t):(r=e,<span class="cstat-no" title="statement not covered" ></span>n=b.get.responseFromXHR(r)),b.remove.loading(),v.onComplete.call(O,n,k,r)},fail:function(e,t,r){var o=b.get.responseFromXHR(e),i=b.get.errorFromRequest(o,t,r);if("aborted"==t)return b.debug("XHR <span class="fstat-no" title="function not covered" >Ab</span>orted (Most<span class="cstat-no" title="statement not covered" > likely caused by page navigation or CORS Policy)",t,r),v.onAbort.call(O,t,k,e),!0;"invalid"==t?b.de</span>bug("J</span>SON did <span class="fstat-no" title="function not covered" >no</span>t pass success test. A ser<span class="cstat-no" title="statement not covered" >ver-s</span>ide <span class="cstat-no" title="statement not covered" >error has most likely occ</span>urre<span class="cstat-no" title="statement not covered" >d",o):"error"==t&amp;&amp;e!==<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(b.debug("XHR produced a server error",t,r),200!=e.status&amp;&amp;r!==n&amp;&amp;""!==r&amp;&amp;b.error(R.statusMessage+r,<span class="fstat-no" title="function not covered" >s.</span>url),v.onEr<span class="cstat-no" title="statement not covered" >ror.call(O,i,k,e)),v.errorDuration&amp;&amp;"aborted"!==t&amp;&amp;(b.debug("Adding error state"),b.set.error(),b.should.removeErro</span>r()&amp;&amp;s</span>etTimeout(b.remove.er<span class="fstat-no" title="function not covered" >ro</span>r,v.errorDurati<span class="cstat-no" title="statement not covered" >on)),b.debug("API Request failed",i,e),v.onFailure.call(O,o,k,e)}}},create:{request:function(){return e.Deferred().always(b.event.request.complete).done(b.event.request.done).fail(b</span>.event.reque<span class="fstat-no" title="function not covered" >st</span>.fail)},mockedXHR:functi<span class="cstat-no" title="statement not covered" >on(){var t,r,n,o=v.mockResponse||v.response,s=v.mockResponseAsync||v.responseAsync;return n=e.Deferred().always(b.event.xhr.com</span>plete).d<span class="fstat-no" title="function not covered" >on</span>e(b.event.xhr.done).fail(b<span class="cstat-no" title="statement not covered" >.event.xhr.fail),o?(e.isF</span>unct<span class="cstat-no" title="statement not covered" >ion(o)?(b.debug("Using specified<span class="cstat-no" title="statement not covered" ></span> synchronous callbac<span class="cstat-no" title="statement not covered" >k",o),r=o.call(O,g)):(b.debug("Using settings specified response",o),r=o),n.resolveWith(O,[r,!1,{responseText:r}])):e.isFun<span class="cstat-no" title="statement not covered" >c</span></span>tion(s)&amp;&amp;(t=function(e){b.debug("Async callback returned response",e),e?n.resolveWith(O,[e,!1,{responseText:e}]):n.rejectWith(O,[{responseText:e},!1,!1])},b.debug("Using specified async response callback",s),s.call(O,g,t)),n},xhr:function(){var t;return t=e.ajax(s).always(b.event.xhr.always).done(b.event.xhr.done).fail(b.event.xhr.fail),b.verbose("Created server request",t,s),t}},set:{error:function(){b.verbose("Adding error state to element",P),P.addClass(x.error)},loading:function(){b.verbose("Adding loading</span> state to element",P),P.a<span class="fstat-no" title="function not covered" >dd</span>Class(x.loa<span class="cstat-no" title="statement not covered" >ding),m=(new Date).getTime()}},remove:{error:function(){b.verbose("Removing error state from element",P),P.r</span>emoveClass(x.<span class="fstat-no" title="function not covered" >er</span>ror)},loading:function(){<span class="cstat-no" title="statement not covered" >b.verbose("Removing loading s</span>tate<span class="cstat-no" title="statement not covered" > from element",P),P.removeClass(x.loadi<span class="cstat-no" title="statement not covered" ></span>ng)}},get:{responseFromXHR:function(t){return!!e.isPlainObject(t)&amp;&amp;(b.is.expectingJSON()?b.decode.json(t.responseText):t.responseText)},errorFromRequest:function(t,r,o){return e.isPlainObject(t)&amp;&amp;t.error!==n?t.error:v.error[r]!==n?v.error[r]:o},request:function(){return b.request||!1},xhr:function(){return b.xhr||!1},settings:<span class="fstat-no" title="function not covered" >fu</span>nction(){var<span class="cstat-no" title="statement not covered" > t;return(t=v.beforeSend.call(O,v))&amp;&amp;(t.success!==n&amp;&amp;(b.debug("Legacy success callback detected",t),b.error(R.legacyParameters,t.success),t.onSuccess</span>=t.success),t.failure!==n&amp;&amp;(b.debug("Legacy failure callback detected",t),b.er</span>ror(R.l<span class="fstat-no" title="function not covered" >eg</span>acyParameters,t.f<span class="cstat-no" title="statement not covered" >ailure),t.onFailure=t.failure),t.complete!==n&amp;&amp;(b.debug("Legacy complete callback detected",t),b.error(R.legacyParameters,t.complete),t.onCom</span>plete=t.complete))<span class="fstat-no" title="function not covered" >,t</span>===n&amp;&amp;b.err<span class="cstat-no" title="statement not covered" >or(R.noReturnedValue),!1===t?t:t!==n?e.extend(!0,{},t):e.extend(!0,{</span>},v)},urlEn<span class="fstat-no" title="function not covered" >co</span>dedValue:fu<span class="cstat-no" title="statement not covered" >nction(e){var r=t.decodeURIComponent(e),n=t.encodeURIComponent(e);return r!==e?(b.debug("URL value</span> is already encoded, <span class="fstat-no" title="function not covered" >av</span>oiding doub<span class="cstat-no" title="statement not covered" >le encoding",e),e):(b.verbose("Encoding value using encodeURIComponent",e,n</span>),n)},defau<span class="fstat-no" title="function not covered" >lt</span>Data:functi<span class="cstat-no" title="statement not covered" >on(){var t={};return e.isWindow(j)||(b.is.input()?t.value=k.val():b.is.form()||</span>(t.text=k.text())),t},event:<span class="fstat-no" title="function not covered" >fu</span>nction(){ret<span class="cstat-no" title="statement not covered" >urn e.isWindow(j)||"now"==v.on?(b.debug("API called without element, no events attached"),!1):"auto"==v.</span>on?k.is("input")?j.o<span class="fstat-no" title="function not covered" >ni</span>nput!==n?"input":j<span class="cstat-no" title="statement not covered" >.onpropertychange!==n?"propertychange":"keyup":k.is("form")?"submit":"click":v.on},templat</span>edURL:funct<span class="fstat-no" title="function not covered" >io</span>n(e){if(e=e<span class="cstat-no" title="statement not covered" >||k.data(y.action)||v.ac</span>tion||!<span class="fstat-no" title="function not covered" >1,</span>f=k.data(y.<span class="cstat-no" title="statement not covered" >url)||v.url||!1)retu</span>rn b.debug("<span class="fstat-no" title="function not covered" >Us</span>ing specified url<span class="cstat-no" title="statement not covered" >",f),f;if(e){if(b.debug("Looking up url for action",e,v.api),v.api[e]===n&amp;&amp;!b.is.mocked())return void b.error(R.missingAction,v.action,v.api);f=v.api[e]}else b.is.form()&amp;&amp;(f=k.attr("action")||P.attr("action")||!1,b.debug("No url or action specified, defaulting to form action",f));return f}},abort:function(){var e=b.get.xhr();e&amp;&amp;"resolved"!==e.state()&amp;&amp;(b.debug("Cancelling API request"),e.abort())},reset:function(){b.remove.error(),b.remove.loading()},setting:function(t,r){if(b.debug("Changing setting",t,r),e.isPlainObject(t))e.extend(!0,v,t);else{if(</span>r===n)return v[t];e<span class="fstat-no" title="function not covered" >.i</span>sPlainObject(v[t])?e<span class="cstat-no" title="statement not covered" >.extend(!0,v[t],r):v[t]=</span>r}},<span class="cstat-no" title="statement not covered" >internal:function(t,r){i<span class="cstat-no" title="statement not covered" ></span>f(e.isPlainObject(t))e.extend(!0,b,t);else{if(r===n)return b[t];b[t]=r}},debug:function(){!v.silent&amp;&amp;v.debug&amp;&amp;(v.performance?b.performance.log(arguments):(b.d</span>ebug=Function.p<span class="fstat-no" title="function not covered" >ro</span>totype.bind.call(co<span class="cstat-no" title="statement not covered" >nso<span class="cstat-no" title="statement not covered" ></span>le.info,console,v.name+":"),b.debug.apply(console,arguments)))},verbose:function(){!v.silent&amp;&amp;v.verb</span>ose&amp;&amp;v.de<span class="fstat-no" title="function not covered" >bu</span>g&amp;&amp;(v.perfo<span class="cstat-no" title="statement not covered" >rmance?b.performance.log(arguments):(b.verbose=Function.prototype.bind.call(console.info,console,v.name+":"),b.verbose.apply(console,arguments)))},error:function(){v.silent||(b.error=Function.prototype.bind.call(console.error,console,v.name+":"),b.error.apply(conso</span>le,arguments))},<span class="fstat-no" title="function not covered" >pe</span>rformance:{l<span class="cstat-no" title="statement not covered" >og:function(e){var t,r;v.performance&amp;&amp;(r=(t=(new Date).getTime())-(a||t),a=t,u.push<span class="cstat-no" title="statement not covered" >({Name:e[0],Arguments:[].slice.call(e,1)||""<span class="cstat-no" title="statement not covered" >,</span></span>"Execut<span class="cstat-no" title="statement not covered" >ion Time":r})),clearTimeout(b.performance.timer),b.performance.timer=setTimeout(b.perf<span class="cstat-no" title="statement not covered" >ormance.display,500)},display:function(){var t=v.name+<span class="cstat-no" title="statement not covered" >"</span></span>:",r=0;a=!1,c</span>learTi<span class="cstat-no" title="statement not covered" >meout(b.performance.timer),e.each(u,function(e,t){r+=t["Execution Time"]}),t+=" "+r+"ms",i&amp;&amp;(t+=" '"+i+"'"),(console.group!==n||conso<span class="cstat-no" title="statement not covered" >l</span></span>e.table!=</span>=n)&amp;&amp;u.leng<span class="fstat-no" title="function not covered" >th</span>&gt;0&amp;&amp;(console.groupC<span class="cstat-no" title="statement not covered" >ollapsed(t),<span class="cstat-no" title="statement not covered" ></span>console.table?console.table(u):e.each(u,function(e,t){console.log(t.Name+": "+t["</span>Execution<span class="fstat-no" title="function not covered" > T</span>ime"]+"ms")<span class="cstat-no" title="statement not covered" >}),console.groupEnd()),u=[]}},invoke:f</span>unction(t,r<span class="fstat-no" title="function not covered" >,s</span>){var i,a,u,c=w<span class="cstat-no" title="statement not covered" >;return r=r||l,s=j||s,"string"==typeof t&amp;&amp;c!==n&amp;&amp;(t=t.split<span class="cstat-no" title="statement not covered" >(/[\. ]/),i=t.length</span>-1,e.<span class="cstat-no" title="statement not covered" >each(t,functi<span class="cstat-no" title="statement not covered" >on(r,o){var <span class="cstat-no" title="statement not covered" >s</span></span>=r!=i?o+t[r+1].charAt(0).toUpperCase()+t[r+1].slice(1):t;</span>i</span>f(e.isPlainO<span class="fstat-no" title="function not covered" >bj</span>ect(c[s])&amp;&amp;r!=i<span class="cstat-no" title="statement not covered" >)c=c[s];else{if(c[s]!==n<span class="cstat-no" title="statement not covered" >)return a=c[s],!1;if</span>(!e.i<span class="cstat-no" title="statement not covered" >sPlainObject(<span class="cstat-no" title="statement not covered" >c[o])||r==i)<span class="cstat-no" title="statement not covered" >r</span></span>eturn c[o</span>]</span>!==n?(a=c<span class="fstat-no" title="function not covered" >[o</span>],!1):(b.er<span class="cstat-no" title="statement not covered" >ror(R.method,t),!1);c=c[o]}})),e.isFunction(a)?u=a.apply(s,r):a!==n&amp;&amp;(u=a),e.isArray(o)?o.push(u):o!==n?o=[o,u]:u!==n&amp;&amp;(o=u),a}},d?(w===n&amp;&amp;b.initialize(),b.invoke(c)):(w!==n&amp;&amp;w.invoke("de</span>stroy"),b.i<span class="fstat-no" title="function not covered" >ni</span>tialize())}<span class="cstat-no" title="statement not covered" >),o!==n?o:this},e.api.settings={name:"API",namespace:"api",debug:!1,verbose:!1,performance:!0,api:{},cache:!0,interruptRequests:!0,on:"auto",stateContext:!1,loadingDuration:0,hideError:"auto",errorDuratio</span>n:2e3,enc<span class="fstat-no" title="function not covered" >od</span>eParameters<span class="cstat-no" title="statement not covered" >:!0,action:!1,url:!1,base:"",urlData:{},defaultData:!0,serializeForm:!1,throttle:0,throttleFirstRequest:!0,method:"get",data:{}</span>,dataType:"json",mockR<span class="fstat-no" title="function not covered" >es</span>ponse:!1,mockResponse<span class="cstat-no" title="statement not covered" >Async:!1,response:!1,responseAsync:!1,beforeSend:function(e){return e},beforeXHR:function(e){},onRequest:function(e,t){},onResponse:!1,onSuccess:function(e,t){},onComplete:function(e,t){},onFailure:function(e,t){},onError:function(e,t){},onAbort:fun</span>ction(e,t){<span class="fstat-no" title="function not covered" >},</span>successTest:!1,erro<span class="cstat-no" title="statement not covered" >r:{beforeSend</span>:"Th<span class="cstat-no" title="statement not covered" >e <span class="cstat-no" title="statement not covered" ></span>before send function has aborted the request",error:"<span class="fstat-no" title="function not covered" >Th</span>ere was an erro<span class="cstat-no" title="statement not covered" >r with your request",exitC</span>onditions:"API Request Aborted. Exit conditions met",JSONParse:"JSON could not be parsed during error handling",legacyParameters:"You are using legacy API success callback names",method:"Th<span class="fstat-no" title="function not covered" >e </span>method you call<span class="cstat-no" title="statement not covered" >ed is not defined",missingAction:"API action used but no </span>url was defined",missingSerializ</span>e:"jquery-se<span class="fstat-no" title="function not covered" >ri</span>alize-object is required to add <span class="cstat-no" title="statement not covered" >fo<span class="cstat-no" title="statement not covered" ></span>rm data to an existing data object",missingURL:"No URL specified for api event",noReturnedValue:"The beforeSend callb<span class="fstat-no" title="function not covered" >ac</span>k must return a setting<span class="cstat-no" title="statement not covered" >s object, beforeSend ignored.",noStorage:"Caching responses locally re<span class="cstat-no" title="statement not covered" ></span>quires session storage",parseError:"T<span class="cstat-no" title="statement not covered" >here was a</span>n err<span class="cstat-no" title="statement not covered" >or parsing your <span class="cstat-no" title="statement not covered" >request",requiredPar<span class="cstat-no" title="statement not covered" >a</span></span>meter:"Missing a required URL paramet<span class="cstat-no" title="statement not covered" >er: ",statusMessage:"Server gave an error: ",timeout:"Your reque<span class="cstat-no" title="statement not covered" >s</span></span>t timed o</span>u</span>t"},regExp:{required:/\{\$*[A-z0-9]+\}/g,optional:/\{\/\$*[A-z0-9]+\}/g},className:{loading:"loading",error:"error"},selector:{disabled</span>:".disabled",form:"form"},metadata:{action:"action",url:"url"}}}(jQuery,window,document);<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Sun Apr 15 2018 11:15:45 GMT+0100 (WEST)
</div>
</div>
<script src="../../../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../../../sorter.js"></script>
<script src="../../../../block-navigation.js"></script>
</body>
</html>
